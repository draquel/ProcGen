#pragma kernel Simplex

RWTexture2D<float4> Result;
int Resolution;

static const float F2 = 0.36602540378;  // 0.5*(sqrt(3.0)-1.0)
static const float G2 = 0.2113248654;   // (3.0-sqrt(3.0))/6.0

// Simplex noise function
float2 grad(int hash, float2 p)
{
    int h = hash & 7;      // Convert low 3 bits of hash code
    float2 grad = float2(1.0, 1.0);  // Gradient vectors
    if (h < 4) grad.x = -1.0;
    if (h < 2) grad.y = -1.0;
    if (h == 1 || h == 2) grad = float2(grad.y, grad.x);
    return grad * dot(p, grad);
}

float hash(int x, int y)
{
    int h = (x * 374761393 + y * 668265263) & 0x7fffffff;
    return (float)h / 2147483648.0;
}

float simplexNoise(float2 p)
{
    float2 s = floor(p + dot(p, float2(F2, F2)));
    float2 x0 = p - s + dot(s, float2(G2, G2));

    int2 i1;
    if (x0.x > x0.y) i1 = int2(1, 0); else i1 = int2(0, 1);

    float2 x1 = x0 - float2(i1) + float2(G2, G2);
    float2 x2 = x0 - float2(1.0, 1.0) + float2(2.0 * G2, 2.0 * G2);

    float n0, n1, n2;
    float t0 = 0.5 - dot(x0, x0);
    if (t0 < 0.0) n0 = 0.0;
    else
    {
        t0 *= t0;
        n0 = t0 * t0 * grad(hash(int(s.x), int(s.y)), x0);
    }

    float t1 = 0.5 - dot(x1, x1);
    if (t1 < 0.0) n1 = 0.0;
    else
    {
        t1 *= t1;
        n1 = t1 * t1 * grad(hash(int(s.x + i1.x), int(s.y + i1.y)), x1);
    }

    float t2 = 0.5 - dot(x2, x2);
    if (t2 < 0.0) n2 = 0.0;
    else
    {
        t2 *= t2;
        n2 = t2 * t2 * grad(hash(int(s.x + 1.0), int(s.y + 1.0)), x2);
    }

    return 70.0 * (n0 + n1 + n2);
}

[numthreads(8, 8, 1)]
void Simplex (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution || id.y >= Resolution) return;

    float2 uv = float2(id.x, id.y) / Resolution;
    float noiseValue = simplexNoise(uv * 10.0); // Scale the UV coordinates

    Result[id.xy] = float4(noiseValue, 0, 0, 1);
}
